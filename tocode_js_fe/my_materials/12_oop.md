בגישת Object Oriented Programming למילה אוביקט יש משמעות שונה מכל מה שלמדנו עד כה ב JavaScript. שם, אוביקט הוא ייצוג של משהו בעולם, שיש לו מצב פנימי ופעולות שיכולות להשפיע על מצבו הפנימי. כתיב מונחה עצמים ב JavaScript מגשר על הפער בצורה מיוחדת, כפי שנראה בשיעור זה.

תוכן עניינים
כתיבת "אוביקט" עם מצב פנימי ופעולות
כתיבת "מחלקה" באמצעות Prototype ופונקציה
קיצור דרך: המילה class
1. כתיבת "אוביקט" עם מצב פנימי ופעולות
התמיכה של שפת JavaScript בפיתוח מונחה עצמים מתחילה באותו אוביקט שבעולם מונחה העצמים מכיל מצב פנימי ופעולות כדי לשנות את מצבו הפנימי.

ניקח לדוגמא משחק של ניחוש מספר בו המחשב בוחר מספר ולנו יש 10 ניחושים כדי לגלות מה היה המספר. אני יודע זה לא המשחק הכי מעניין בעולם אבל אני מקווה שבכל זאת הוא יעזור לנו ללמוד על תכנות מונחה עצמים.

במשחק הזה אפשר לייצג את המספר הסודי שהמחשב בחר ואת מספר הניסיונות שעשינו עד כה בתור מצבו הפנימי של האוביקט. הפעולות יהיו "התחל משחק חדש", ו"נחש מספר". וכל פעולת "נחש מספר" תחזיר 1 אם המספר שניחשתי גדול מזה שהמחשב בחר, -1 אם המספר של המחשב היה גדול יותר ו-0 אם המספרים שווים.

ראינו בשיעור הקודם איך לשלב פונקציה ואוביקט ולכן אוכל להשתמש בכלי זה כדי לכתוב את האוביקט למשחק:

const game = {
    secret: 0,
    numberOfTries: 10,

    startNewGame() {
        this.secret= Math.floor(Math.random() * 10);
        this.numberOfTries = 0;
    },

    play(guess) {
        if (this.numberOfTries >= 10) {
            // Sorry, game over
            return;
        }
        this.numberOfTries += 1;
        if (guess > this.secret) {
            return 1;
        } else if (guess < this.secret) {
            return -1;
        } else {
            return 0;
        }
    }
}
מוזמנים להדביק את הקוד לדפדפן ולשחק קצת. אחרי שתסיימו בואו נראה מה יצרנו כאן:

יש לנו אוביקט בשם game שכאילו מייצג "סוג של משחק"

אנחנו יכולים לשלוח הודעות לאוביקט זה, כמו בתכנות מונחה עצמים.

לאוביקט יש מצב פנימי עליו הפעולות יכולות להשפיע.

מה שעדיין נראה שונה מתכנות מונחה עצמים קלאסי זה שבתכנות מונחה עצמים אנחנו רגילים שיש משהו נוסף, משהו שנקרא מחלקה. מחלקה היא הדרך לייצר עוד ועוד אוביקטים, למשל כדי לקיים מספר משחקים במקביל.

2. כתיבת "מחלקה" באמצעות Prototype ופונקציה
הרעיון הראשון שעשוי לעלות אם אבקש מכם להפוך את האוביקט שכתבנו למחלקה הוא ליצור פונקציה שמחזירה כאלה אוביקטים. לדוגמא עבור אוביקט שמייצג בן אדם היינו יכולים לדמיין פונקציה כזו:

function Person(name) {
    const person = {
        name: name,
        hello() {
            console.log(`Hi! ${this.name}`);
        },
    }
    return person;
}

const p1 = Person('one');
const p2 = Person('two');
וזה עובד. כלומר אתם יכולים לכתוב:

p1.hello();
ולקבל את הודעת ההדפסה הנכונה. אבל זה גם לא עובד, או לפחות לא עובד בצורה יעילה.

בדרך כלל כשאנחנו חושבים על תכנות מונחה עצמים ומחלקות אנחנו חושבים שכל האוביקטים שנוצרים מאותה מחלקה מכילים בדיוק את אותן פונקציות, אבל עותקים שונים של שדות המידע. הבעיה בקוד שכתבנו היא שכתיב כזה מייצר עותק חדש לכל אחת מהפונקציות כל פעם שמפעילים את הפונקציה Person. אפשר להוכיח את זה בקלות:

>> p1.hello === p2.hello
false
וזה מטריד, כי זה אומר שכל אוביקט חדש שניצור יבנה עותק חדש של כל הפונקציות ויתפוס יותר זיכרון ממה שהיה צריך.

לכן שפת JavaScript הוסיפה מנגנון שנקרא Prototype שעוזר לנו לכתוב קוד מונחה עצמים בצורה חסכונית. אם הבעיה שלנו היא שכל אוביקט מחזיק עותק משלו של כל הפונקציות, ג'אווהסקריפט מאפשרת לנו ליצור אוביקט אחד שישמור לכולם את הפונקציות. כל אוביקט יחזיק "קישור מיוחד" לאותו אוביקט ראשי, שנקרא אוביקט פרוטוטייפ. כל פעם שנרצה להפעיל פונקציה על אוביקט, באופן אוטומטי JavaScript יחפש את הפונקציה הזאת באוביקט הפרוטוטייפ שלו.

וכן גם לאוביקט פרוטוטייפ יכול להיות אוביקט פרוטוטייפ וכך בשרשרת עד אין סוף.

מה שקצת מבלבל הוא שבשביל להגדיר אוביקט Prototype לאוביקט שלנו אנחנו צריכים לבצע מספר שינויים בקוד שבמבט ראשון אולי לא נראים קשורים:

אנחנו צריכים להגדיר על הפונקציה שיוצרת את האוביקטים מאפיין בשם prototype.

אנחנו צריכים להפעיל את הפונקציה שיוצרת את האוביקטים עם המילה השמורה new לפניה כדי לקבל אוביקטים חדשים.

המשתנה המיוחד this בתוך הפונקציה שיוצרת את האוביקטים יועבר לנו אוטומטית ויחזיק בתור ערך אוביקט חדש ש JavaScript כבר הגדיר לו את אוביקט הפרוטוטייפ לפי מה שכתוב בפונקציה. לכן אנחנו חייבים להשתמש באוביקט זה ולא להגדיר אחד משלנו בתוך גוף הפונקציה. אין צורך להחזיר אותו, ג'אווהסקריפט מטפל בזה אוטומטית בשבילנו.

אחרי שלושת השינויים הקוד יראה כך:

function Person(name) {
    this.name = name;
}

Person.prototype.hello = function() {
    console.log(`Hi! ${this.name}`);
}

המילה new והשימוש ב this כבר ממש נותנים לנו הרגשה של תכנות מונחה עצמים. המילה Person.prototype קצת פחות, אבל מתרגלים לחיות עם זה. לפונקציה Person מוגדר עכשיו המאפיין Person.prototype, ערכו של מאפיין זה הוא אוביקט ולו שדה בשם hello, ובשדה זה שמורה הפונקציה שמדפיסה את ברכת השלום.

הקוד הבא:

const p1 = new Person('one');
const p2 = new Person('two');
יוצר עכשיו שני אוביקטים חדשים שלכל אחד מהם יש חיבור מיוחד לאותו Person.prototype שהגדרנו קודם. כל פעם שננסה לקרוא לפונקציה hello של כל אחד מהאוביקטים נגיע לפונקציה hello של אותו אוביקט Person.prototype:

>> p1.hello === p2.hello
true

>> p2.hello === Person.prototype.hello
true
3. קיצור דרך: המילה class
כתיב ה Prototype תסכל וממשיך לתסכל מתכנתים שמגיעים מרקע של תכנות מונחה עצמים שציפו למצוא ב JavaScript מבנים דומים ל Java והתאכזבו. היום JavaScript כבר מציעה קיצור דרך נחמד לכתיב הפרוטוטייפ באמצעות המילה השמורה class.

הקוד הבא עבור Person שקול לגמרי לקוד שכתבנו קודם:

class Person {
    constructor(name) {
        this.name = name;
    }

    hello() {
        console.log(`Hi! ${this.name}`);
    }
}

const p1 = new Person('one');
const p2 = new Person('two');
המילה class מגדירה את המחלקה כמבנה יחיד, המילה constructor מגדירה את קוד האיתחול שיופעל כשיוצרים אוביקטים חדשים והפונקציה hello נראית ממש כמו מתודה.

אנחנו כמובן כבר יודעים שמדובר בסך הכל בסוכר תחבירי, ולכן לא נופתע לראות ש:

>> typeof Person
"function"
וכמובן ש:

>> Person.prototype.hello === p1.hello
true
כתיב מונחה עצמים ב JavaScript הוא הבסיס ליישומים גדולים רבים שנכתבים היום ב JavaScript ונמצא בשימוש בפריימוורקס פיתוח רבים כמו Angular, Vue ו React.